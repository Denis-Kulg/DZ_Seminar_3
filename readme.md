# Git

## Что такое Git?

**Git (произносится «гит»)** — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.
## Подготовка репозитория

Обычно вы получаете репозиторий Git одним из двух способов:

1. Вы можете взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git, либо

2. Вы можете клонировать существующий репозиторий Git из любого места.

В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.
Создание репозитория в существующем каталоге
Если у вас уже есть проект в каталоге, который не находится под версионным контролем Git, то для начала нужно перейти в него. Если вы не делали этого раньше, то для разных операционных систем это выглядит по-разному:

    Для windows:

             $ cd C:/Users/user/my_project

    а затем выполните команду:

                 $ git init


## Создание «сохранений»

Следующее, что нужно знать — команда _git add._ Она позволяет внести в индекс — временное хранилище — изменения, которые затем войдут в коммит.

Индексирует измененный файл, либо оповещение о создании нового:
_git add EDITEDFILE_
Вносит в индекс все изменения, включая новые файлы:
_git add._

**Git status — состояние проекта, измененные и не добавленные файлы, индексированные файлы.**

Команду git status, пожалуй, можно считать самой часто используемой наряду с командами коммита и индексации. Она выводит информацию обо всех изменениях, внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей ветки; отдельно выводятся внесенные в индекс и неиндексированные файлы. Использовать ее крайне просто:
_git status_

Кроме того, _git status_ указывает на файлы с неразрешенными конфликтами слияния и файлы, игнорируемые _git_.

**Git commit — совершение коммита.**

*Коммит* — базовое понятие во всех системах контроля версий, поэтому совершаться он должен легко и по возможности быстро. В простейшем случае достаточно после индексации набрать:
git commit
Если индекс не пустой, то на его основе будет совершен коммит, после чего пользователя попросят прокомментировать вносимые изменения вызовом команды _edit._ Сохраняемся, и вуаля! Коммит готов. Есть несколько ключей, упрощающих работу с _git commit._
Совершает коммит, автоматически индексируя изменения в файлах проекта. Новые файлы при этом индексироваться не будут!

 С помощью команды _**rebase**_ вы можете взять все коммиты из одной ветки и в том же порядке применить их к другой ветке.

В данном примере переключимся на ветку experimentи перебазируем ее относительно ветки master следующим образом:

    $ git checkout experiment

    $ git rebase master

First, rewinding head to replay your work on top of it...

Applying: added staged command


Это работает следующим образом: берётся общий родительский снимок двух веток. а затем по очереди применяются дельты из временных файлов.

Перебазирование изменений из `C4` поверх` C3`
Рисунок 37. Перебазирование изменений из C4 поверх C3
После этого вы можете переключиться обратно на ветку _**master**_ и выполнить с влиянием перемоткой.

    $ git checkout master
    $ git merge experiment

## Git log — разнообразная информация о коммитах в целом.

Иногда требуется получить информацию об истории коммитов; коммитах, изменивших отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих целей используется команда _**git log.**_

Простейший пример использования, в котором приводится короткая справка по всем коммитам, коснувшимся активной в настоящий момент ветки (о ветках и ветвлении подробно узнать можно ниже, в разделе «Ветвления и слияния»):
 _**git log.**_

Получает подробную информацию о каждом в виде патчей по файлам из коммитов можно, добавив ключ -p (или -u):
 _**git log. -p**_

Статистика изменения файлов, вроде числа измененных файлов, внесенных в них строк, удаленных файлов вызывается ключом --stat:
 _**git log. --stat**_

За информацию по созданиям, переименованиям и правам доступа файлов отвечает ключ --summary:
_**git log --summary**_

Чтобы просмотреть историю отдельного файла, достаточно указать в виде параметра его имя (кстати, в моей старой версии git этот способ не срабатывает, обязательно добавлять " — " перед «README»):
git log README
или, если версия git не совсем свежая:
git log — README

Далее приводится только более современный вариант синтаксиса. Возможно указывать время, начиная в определенного момента («weeks», «days», «hours», «s» и так далее):

    $git log --since=«1 day 2 hours» README
    $git log --since=«2 hours» README

    Изменения, касающиеся отдельной папки:
    $git log --since=«2 hours» dir/

Можно отталкиваться от тегов.
Все коммиты, начиная с тега v1:
git log v1...

Все коммиты, включающие изменения файла README, начиная с тега v1:
git log v1... README

Все коммиты, включающие изменения файла README, начиная с тега v1 и заканчивая тегом v2:
git log v1..v2 README

Интересные возможности по формату вывода команды предоставляет ключ --pretty.
Выводит на каждый из коммитов по строчке, состоящей из хэша (здесь — уникального идентификатора каждого коммита, подробней — дальше):
git log --pretty=oneline

Лаконичная информация о коммитах, приводятся только автор и комментарий:
git log --pretty=short

Более полная информация о коммитах, с именем автора, комментарием, датой создания и внесения коммита:
git log --pretty=full/fuller

В принципе, формат вывода можно определить самостоятельно:
git log --pretty=format:'FORMAT'

Определение формата можно поискать в разделе по git log из Git Community Book или справке.
 Красивый ASCII-граф коммитов выводится с использованием ключа --graph.



тут и add, и status, и commit?
тут и add, и status, и commit!

Хочу ли я создать конфликт?

Хочу создать конфликт
