# Git

## Что такое Git?

**Git (произносится «гит»)** — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.
## Подготовка репозитория

Обычно вы получаете репозиторий Git одним из двух способов:

1. Вы можете взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git, либо

2. Вы можете клонировать существующий репозиторий Git из любого места.

В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.
Создание репозитория в существующем каталоге
Если у вас уже есть проект в каталоге, который не находится под версионным контролем Git, то для начала нужно перейти в него. Если вы не делали этого раньше, то для разных операционных систем это выглядит по-разному:

    Для windows:

              cd C:/Users/user/my_project

    а затем выполните команду:

                  git init


## Создание «сохранений»

Следующее, что нужно знать — команда _git add._ Она позволяет внести в индекс — временное хранилище — изменения, которые затем войдут в коммит.

Индексирует измененный файл, либо оповещение о создании нового:
_git add EDITEDFILE_
Вносит в индекс все изменения, включая новые файлы:
_git add._

**Git status — состояние проекта, измененные и не добавленные файлы, индексированные файлы.**

Команду git status, пожалуй, можно считать самой часто используемой наряду с командами коммита и индексации. Она выводит информацию обо всех изменениях, внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей ветки; отдельно выводятся внесенные в индекс и неиндексированные файлы. Использовать ее крайне просто:
_git status_

Кроме того, _git status_ указывает на файлы с неразрешенными конфликтами слияния и файлы, игнорируемые _git_.

**Git commit — совершение коммита.**

*Коммит* — базовое понятие во всех системах контроля версий, поэтому совершаться он должен легко и по возможности быстро. В простейшем случае достаточно после индексации набрать:
git commit
Если индекс не пустой, то на его основе будет совершен коммит, после чего пользователя попросят прокомментировать вносимые изменения вызовом команды _edit._ Сохраняемся, и вуаля! Коммит готов. Есть несколько ключей, упрощающих работу с _git commit._
Совершает коммит, автоматически индексируя изменения в файлах проекта. Новые файлы при этом индексироваться не будут!

 С помощью команды _**rebase**_ вы можете взять все коммиты из одной ветки и в том же порядке применить их к другой ветке.

В данном примере переключимся на ветку experimentи перебазируем ее относительно ветки master следующим образом:

    $ git checkout experiment

    $ git rebase master

First, rewinding head to replay your work on top of it...

Applying: added staged command


Это работает следующим образом: берётся общий родительский снимок двух веток. а затем по очереди применяются дельты из временных файлов.

Перебазирование изменений из `C4` поверх` C3`
Рисунок 37. Перебазирование изменений из C4 поверх C3
После этого вы можете переключиться обратно на ветку _**master**_ и выполнить с влиянием перемоткой.

    $ git checkout master
    $ git merge experiment

## Git log — разнообразная информация о коммитах в целом.

Иногда требуется получить информацию об истории коммитов; коммитах, изменивших отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих целей используется команда _**git log.**_

Простейший пример использования, в котором приводится короткая справка по всем коммитам, коснувшимся активной в настоящий момент ветки (о ветках и ветвлении подробно узнать можно ниже, в разделе «Ветвления и слияния»):
 _**git log.**_

Получает подробную информацию о каждом в виде патчей по файлам из коммитов можно, добавив ключ -p (или -u):
 _**git log. -p**_

Статистика изменения файлов, вроде числа измененных файлов, внесенных в них строк, удаленных файлов вызывается ключом --stat:
 _**git log. --stat**_

За информацию по созданиям, переименованиям и правам доступа файлов отвечает ключ --summary:
_**git log --summary**_

Чтобы просмотреть историю отдельного файла, достаточно указать в виде параметра его имя (кстати, в моей старой версии git этот способ не срабатывает, обязательно добавлять " — " перед «README»):
git log README
или, если версия git не совсем свежая:
git log — README

Далее приводится только более современный вариант синтаксиса. Возможно указывать время, начиная в определенного момента («weeks», «days», «hours», «s» и так далее):

    $git log --since=«1 day 2 hours» README
    $git log --since=«2 hours» README

    Изменения, касающиеся отдельной папки:
    $git log --since=«2 hours» dir/

Можно отталкиваться от тегов.
Все коммиты, начиная с тега v1:
git log v1...

Все коммиты, включающие изменения файла README, начиная с тега v1:
git log v1... README

Все коммиты, включающие изменения файла README, начиная с тега v1 и заканчивая тегом v2:
git log v1..v2 README

Интересные возможности по формату вывода команды предоставляет ключ --pretty.
Выводит на каждый из коммитов по строчке, состоящей из хэша (здесь — уникального идентификатора каждого коммита, подробней — дальше):
git log --pretty=oneline

Лаконичная информация о коммитах, приводятся только автор и комментарий:
git log --pretty=short

Более полная информация о коммитах, с именем автора, комментарием, датой создания и внесения коммита:
git log --pretty=full/fuller

В принципе, формат вывода можно определить самостоятельно:
git log --pretty=format:'FORMAT'

Определение формата можно поискать в разделе по git log из Git Community Book или справке.
 Красивый ASCII-граф коммитов выводится с использованием ключа --graph.

## Ветвление

### Git branch — создание, перечисление и удаление веток.
    
_Работа с ветками_ — очень легкая процедура в git, все необходимые механизмы сконцентрированы в одной команде.
Просто перечисляет существующие ветки, отметив активную:
git branch

Создаёт новую ветку new-branch:
git branch new-branch

Удаляет ветку, если та была залита (merged) с разрешением возможных конфликтов в текущую:
git branch -d new-branch
Удаляет ветку в любом случае:
git branch -D new-branch

Переименовывает ветку:
git branch -m new-name-branch

Показывывает те ветки, среди предков которых есть определенный коммит:
git branch --contains v1.2

Показывает коммит ответвления ветки new-name-branch от ветки master:
git merge-base master new-name-branch

**git checkout — переключение между ветками, извлечение файлов**

Команда git checkout позволяет переключаться между последними коммитами (если упрощенно) веток:
checkout some-other-branch

Создаёт ветку, в которую и произойдет переключение:
git checkout -b some-other-new-branch

Если в текущей ветке были какие-то изменения по сравнению с последним коммитом в ветке(HEAD), то команда откажется производить переключение, дабы не потерять произведенную работу.
Проигнорировать этот факт позволяет ключ -f:
git checkout -f some-other-branch

В случае, когда изменения надо все же сохранить, следует использовать ключ -m. Тогда команда перед переключением попробует залить изменения в текущую ветку и, после разрешения возможных конфликтов переключиться в новую:
git checkout -m some-other-branch

Вернуть файл (или просто вытащить из прошлого коммита) позволяет команда вида:
git checkout somefile

Возвращает somefile к состоянию последнего коммита:
git checkout somefile

Возвращает somefile к состоянию на два коммита назад по ветке:
git checkout HEAD~2 somefile

## Git merge — слияние веток, разрешение возможных конфликтов.

Слияние веток, в отличие от обычной практики централизованных систем, в git происходит практически каждый день. Естественно, что имеется удобный интерфейс к популярной операции.

Пытается объединить текующую ветку и ветку new-feature:
git merge new-feature

В случае возникновения конфликтов коммита не происходит, а по проблемным файлам расставляются специальные метки а-ля svn; сами же файлы отмечаются в индексе как «не соединенные» (unmerged). До тех пор пока проблемы не будут решены, коммит совершить будет нельзя.

Например, конфликт возник в файле TROUBLE, что можно увидеть в git status.

Произошла неудачная попытка слияния:
git merge experiment

Смотрим на проблемные места:
git status

Разрешаем проблемы:
edit TROUBLE
Индексируем наши изменения, тем самым снимая метки:
git add .
Совершаем коммит слияния:
git commit
Вот и все, ничего сложного. Если в процессе разрешения вы передумали разрешать конфликт, достаточно набрать (это вернёт обе ветки в исходные состояния):
git reset --hard HEAD
Если же коммит слияния был совершен, используем команду:
git reset --hard ORIG_HEAD


## Удаление веток
Для организации разработки различных версий программного обеспечения в Git используются ветки. Ветки также очень часто используются для разработки новой функциональности в программе. Если разработкой продукта занимается команда, каждый разработчик может работать над своей частью функциональности в отдельной ветке.
Когда работа будет завершена, получившуюся ветку можно будет совместить с основной перед этим отправив её на проверку другим участникам команды. При таком рабочем процессе со временем накапливается много ненужных веток, которые надо удалять. В этой небольшой статье мы рассмотрим как удалить ветку локально и удаленно git.
Прежде чем что-либо удалять необходимо посмотреть какие ветки у вас есть. Для того чтобы посмотреть локальные ветки используйте такую команду в папке с репозиторием:
**git branch**
Команда выведет список локальных веток, а текущая ветка будет выделена зеленым цветом и звездочкой. Для того чтобы удалить ветку необходимо использовать ту же команду branch с опцией -d. Например, для того чтобы удалить ветку feature/somefeature1 выполните такую команду:
git branch -d feature/somefeature1
Или:
git branch --delete feature/somefeature1
Если в этой ветке есть не зафиксированные изменения или коммиты, не отправленные на сервер, то программа может отказаться её удалять. Для того чтобы всё же удалить такую ветку используйте опцию -D:
git branch -D feature/somefeature1
 Или:
git branch --delete --force feature/somefeature1
Удаление ветки Git завершено, если после этого вы снова проверите список локальных веток, то этой ветки там больше не будет.

## Работа с удалёнными репозиториями

Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим некоторые из этих навыков.

### *Просмотр удалённых репозиториев*

Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование.

Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:

    $ git remote -v
    origin	https://github.com/schacon/ticgit (fetch)
    origin	https://github.com/schacon/ticgit (push)

### *Добавление удалённых репозиториев*

В предыдущих разделах мы уже упоминали и приводили примеры добавления удалённых репозиториев, сейчас рассмотрим эту операцию подробнее. Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду git remote add (shortname) (url)

Теперь вместо указания полного пути вы можете использовать pb. Например, если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду git fetch pb

Ветка master из репозитория Пола сейчас доступна вам под именем pb/master. Вы можете слить её с одной из ваших веток или переключить на неё локальную ветку, чтобы просмотреть содержимое ветки Пола. 

Отправка изменений в удаленный репозиторий (Push)
Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: git push (remote-name) (branch-name). Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

    $ git push origin master
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push.

## *Просмотр удаленного репозитория*
Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду git remote show (remote).


